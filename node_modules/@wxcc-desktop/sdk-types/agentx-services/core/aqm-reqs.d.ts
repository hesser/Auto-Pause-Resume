import { Err, Signal } from "@uuip/unified-ui-platform-sdk";
import { AxiosError, AxiosResponse } from "axios";
import { AqmNotifs } from "./aqm-notifs";
export declare const TIMEOUT_REQ = 20000;
export declare class AqmReqs {
    private pendingRequests;
    private pendingEvents;
    private pendingNotifCancelrequest;
    private readonly auth;
    constructor(notifs: AqmNotifs);
    req<TRes, TErr, TReq>(c: Conf<TRes, TErr, TReq>): Res<TRes, TReq>;
    reqEmpty<TRes, TErr>(c: ConfEmpty<TRes, TErr>): ResEmpty<TRes>;
    evt<T>(p: EvtConf<T>): EvtRes<T>;
    private fetchNewToken;
    private makeAPIRequest;
    private createPromise;
    private bindPrint;
    private bindCheck;
    private readonly identifyInteractionIsTaskObject;
    private isFlowValuesEncrypted;
    private isValidCADFlowValue;
    private isValidCPDFlowValue;
    private getDecompressedValue;
    private readonly onMessage;
}
declare module "@uuip/unified-ui-platform-sdk" {
    namespace Err {
        interface Ids {
            "Service.aqm.reqs": ReqError;
        }
    }
}
export type Msg<T = any> = {
    type: string;
    orgId: string;
    trackingId: string;
    data: T;
};
type ReqError = "Service.aqm.reqs.GenericRequestError" | {
    "Service.aqm.reqs.Pending": {
        key: string;
        msg: string;
    };
} | {
    "Service.aqm.reqs.PendingEvent": {
        key: string;
    };
} | {
    "Service.aqm.reqs.Timeout": {
        key: string;
        resAxios: AxiosResponse;
    };
} | {
    "Service.aqm.reqs.TimeoutEvent": {
        key: string;
    };
};
type BindType = string | string[] | {
    [key: string]: BindType;
};
interface Bind {
    type: BindType;
    data?: any;
}
type updateMethods = "get" | "post" | "put" | "patch";
type Req<TRes, TErr> = {
    url: string;
    host?: string;
    method?: updateMethods;
    err?: ((errObj: AxiosError<any>) => Err.Details<"Service.reqs.generic.failure">) | Err.IdsMessage | ((e: AxiosError) => Err.Message | Err.Details<Err.IdsDetails>);
    notifSuccess: {
        bind: Bind;
        msg: TRes;
    };
    notifFail?: {
        bind: Bind;
        errMsg: TErr;
        err: (e: TErr) => Err.Details<Err.IdsDetails>;
    } | {
        bind: Bind;
        errId: Err.IdsDetails;
    };
    data?: any;
    headers?: Record<string, string>;
    timeout?: Timeout;
    notifCancel?: {
        bind: Bind;
        msg: TRes;
    };
};
type Timeout = number | "disabled";
type Conf<TRes, TErr, TReq> = (p: TReq) => Req<TRes, TErr>;
type ConfEmpty<TRes, TErr> = () => Req<TRes, TErr>;
export type Res<TRes, TReq> = (p: TReq, cbRes?: CbRes<TRes>) => Promise<TRes>;
export type ResEmpty<TRes> = (cbRes?: CbRes<TRes>) => Promise<TRes>;
type CbRes<TRes> = (res: any) => void | TRes;
type EvtConf<T> = {
    bind: Bind;
    msg: T;
};
type EvtRes<T> = Signal.WithData<T> & {
    listenOnceAsync: (p?: {
        resolveIf?: (msg: T) => boolean;
        timeout?: Timeout;
    }) => Promise<T>;
};
export {};
//# sourceMappingURL=aqm-reqs.d.ts.map